#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"

static const float CLOUD_BOUNDS = 100.0;

//static const float NOISE_FREQ = 0.01;
//Texture3D<float> AlligatorNoise;

/// Cloud Volume Sample.
struct CloudSample {
    float Value;
    
    /// Returns true if this sample is outside the volume.
    inline bool IsOutside() { return Value > 0.0; }
    /// Returns the density of the cloud for this sample. (if `IsOutside() == false`)
    inline float Density() { return -Value; }
    /// Returns the signed distance to the cloud for this sample. (if `IsOutside() == true`)
    inline float SDist() { return Value; }
    
    /// Create a cloud sample which resides outside the cloud.
    static CloudSample Outside(const float SDist) { return (CloudSample)SDist; }
    /// Create a cloud sample which resides inside the cloud.
    static CloudSample Inside(const float Density) { return (CloudSample)(-Density); }
};

/// Cloud Render Data.
struct CloudParameters {
    // Volume Data
    float3 Position;
    float3 Absorption;
    float Density;
    
    // Light Data
    float3 SunDir;
    float3 SunLuminance;
    
    // Performance
    float MinStepSize;
    float InnerStepSize;
    float StepSizeMult;
    float ExtinctionThreshold;
    
    // Textures
    Texture3D<float> DensityTexture;
    Texture3D<float> SDFTexture;
};

/// Sample the cloud.
CloudSample SampleCloud(ConstantBuffer<CloudParameters> Cloud, const float3 UVW) {
    // Sample the signed distance field.
    //const float NormSDist = Cloud.SDFTexture.Sample(GlobalBilinearClampedSampler, UVW);
        
    // If the distance is above zero, we're outside the cloud, return the signed distance.
    //if (NormSDist > 0.0) {
    //    // Convert the normalized signed distance to world-space.
    //    const float SDist = NormSDist * length(float3(CLOUD_BOUNDS, CLOUD_BOUNDS, CLOUD_BOUNDS) * 2.0);
    //    return CloudSample::Outside(SDist);
    //}
    
    // We're inside the volume, so we fetch the density and return it instead.
    const float Density = Cloud.DensityTexture.Sample(GlobalBilinearClampedSampler, UVW);
    if (Density <= 0.0) return CloudSample::Outside(3.0);
    return CloudSample::Inside(Density * Cloud.Density);
    // const float Erosion = AlligatorNoise.Sample(GlobalBilinearWrappedSampler, UVW * NOISE_FREQ);
    // return CloudSample::Inside(max(Density - (Erosion * Erosion), 0.0) * Cloud.Density);
}

/// Get the entry distance of a ray with an AABB.
float2 RayAABB(const float3 RayOrigin, const float3 RayDir, const float3 BoxMin, const float3 BoxMax) {
    float3 T0 = (BoxMin - RayOrigin) / RayDir;
    float3 T1 = (BoxMax - RayOrigin) / RayDir;
    
    const float3 Temp = T0;
    T0 = min(Temp, T1), T1 = max(Temp, T1);
 
    const float TMin = max(max(max(T0.x, T0.y), T0.z), 0.0);
    const float TMax = min(min(T1.x, T1.y), T1.z);
    return float2(TMin, TMax);
};

/// Get the UV coordinate for a given pixel.
float2 GetPixelUV(const uint2 Pixel) { return (float2(Pixel) + 0.5 - View.TemporalAAJitter.xy) * View.ViewSizeAndInvSize.zw; }

/// Get the depth value for a given pixel along the given ray.
float TransformPixelDepth(const float DeviceZ, const float3 RayDirection) { return ConvertFromDeviceZ(DeviceZ) / dot(RayDirection, View.ViewForward); }

/// Get the ray origin of the current view.
float3 GetRayOrigin() { return View.WorldViewOriginHigh + View.WorldViewOriginLow; }

/// Get the ray direction of the current view for a given UV coordinate.
float3 GetRayDirection(const float2 UV) {
    // Reconstruct view space position on the far plane
    float2 NDC = (UV - 0.5) * 2.0;
    NDC.y = -NDC.y;
    
    // Unproject from clip space to view space
    const float4 ClipPos = float4(NDC, 1.0f, 1.0f);
    float4 ViewPos = mul(ClipPos, View.ClipToView);
    ViewPos.xyz /= ViewPos.w;
    
    // Transform view space direction to world space
    return normalize(mul(float4(ViewPos.xyz, 0.0f), View.ViewToTranslatedWorld).xyz);
}
