#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"

static const float CLOUD_BOUNDS = 100.0;
static const float UNITS_PER_VOXEL = (CLOUD_BOUNDS * 2.0) / 64.0;

//static const float NOISE_FREQ = 0.01;
//Texture3D<float> AlligatorNoise;

/// Cloud Volume Sample.
struct CloudSample {
    float Value;
    
    /// Returns true if this sample is outside the volume.
    inline bool IsOutside() { return Value > 0.0; }
    /// Returns the density of the cloud for this sample. (if `IsOutside() == false`)
    inline float Density() { return -Value; }
    /// Returns the signed distance to the cloud for this sample. (if `IsOutside() == true`)
    inline float SDist() { return Value; }
    
    /// Create a cloud sample which resides outside the cloud.
    static CloudSample Outside(const float SDist) { return (CloudSample)SDist; }
    /// Create a cloud sample which resides inside the cloud.
    static CloudSample Inside(const float Density) { return (CloudSample)(-Density); }
};

/// Cloud Render Data.
struct CloudParameters {
    // Volume Data
    float3 Position;
    float3 Absorption;
    float Density;
    
    // Light Data
    float3 SunDir;
    float3 SunLuminance;
    
    // Performance
    float MinStepSize;
    float InnerStepSize;
    float StepSizeMult;
    float ExtinctionThreshold;
    
    // Textures
    Texture3D<float> DensityTexture;
    Texture3D<float> SDFTexture;
};

/// Remap an input value in an input range to an output range.
float Remap(const float Value, const float InMin, const float InMax, const float OutMin, const float OutMax) {
    const float Range = InMax - InMin;
    const float Norm = (Value - InMin) / Range;
    const float Clamped = (Norm < 0.0) ? 0.0 : (Norm > 1.0) ? 1.0 : Norm;
    return OutMin + (Clamped * (OutMax - OutMin));
}

/// Sample the cloud.
CloudSample SampleCloud(ConstantBuffer<CloudParameters> Cloud, const float3 UVW) {
    // Sample the Signed Distance Field.
    // The SDF is stored from -256 to 4096 in a UNorm texture encoded in voxel-space.
    const float NormSDist = Cloud.SDFTexture.Sample(GlobalBilinearClampedSampler, UVW);
    const float SDist = (NormSDist * 4352.0 - 256.0) * UNITS_PER_VOXEL;
    
    // If the distance is above zero, we're outside the cloud, return the signed distance.
    if (SDist > 0.0) return CloudSample::Outside(SDist);
    
    // We're inside the volume, so we fetch the density and return it instead.
    const float Density = Cloud.DensityTexture.Sample(GlobalBilinearClampedSampler, UVW);
    return CloudSample::Inside(Density * Cloud.Density);
    // const float Erosion = AlligatorNoise.Sample(GlobalBilinearWrappedSampler, UVW * NOISE_FREQ);
    // return CloudSample::Inside(max(Density - (Erosion * Erosion), 0.0) * Cloud.Density);
}

/// Get the entry distance of a ray with an AABB.
float2 RayAABB(const float3 RayOrigin, const float3 RayDir, const float3 BoxMin, const float3 BoxMax) {
    float3 T0 = (BoxMin - RayOrigin) / RayDir;
    float3 T1 = (BoxMax - RayOrigin) / RayDir;
    
    const float3 Temp = T0;
    T0 = min(Temp, T1), T1 = max(Temp, T1);
 
    const float TMin = max(max(max(T0.x, T0.y), T0.z), 0.0);
    const float TMax = min(min(T1.x, T1.y), T1.z);
    return float2(TMin, TMax);
};

/// Get the UV coordinate for a given pixel.
float2 GetPixelUV(const uint2 Pixel) { return (float2(Pixel) + 0.5 - View.TemporalAAJitter.xy) * View.ViewSizeAndInvSize.zw; }

/// Get the depth value for a given pixel along the given ray.
float TransformPixelDepth(const float DeviceZ, const float3 RayDirection) { return ConvertFromDeviceZ(DeviceZ) / dot(RayDirection, View.ViewForward); }

/// Get the ray origin of the current view.
float3 GetRayOrigin() { return View.WorldViewOriginHigh + View.WorldViewOriginLow; }

/// Get the ray direction of the current view for a given UV coordinate.
float3 GetRayDirection(const float2 UV) {
    // Reconstruct view space position on the far plane
    float2 NDC = (UV - 0.5) * 2.0;
    NDC.y = -NDC.y;
    
    // Unproject from clip space to view space
    const float4 ClipPos = float4(NDC, 1.0f, 1.0f);
    float4 ViewPos = mul(ClipPos, View.ClipToView);
    ViewPos.xyz /= ViewPos.w;
    
    // Transform view space direction to world space
    return normalize(mul(float4(ViewPos.xyz, 0.0f), View.ViewToTranslatedWorld).xyz);
}
