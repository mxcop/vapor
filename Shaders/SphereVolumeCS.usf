#include "Common.ush"

// Ray Marching Parameters
static const uint MAX_DIRECT_STEPS = 128;
static const uint MAX_INDIRECT_STEPS = 128;

// Volume Parameters
static const float SPHERE_SIZE = 100.0; // cm

struct CloudParameters {
    // Volume Data
    float3 Position;
    float3 Absorption;
    float Density;
    
    // Light Data
    float3 SunDir;
    float3 SunLuminance;
    
    // Performance
    float MinStepSize;
    int Method;
};

// Cloud Parameters
ConstantBuffer<CloudParameters> Cloud;

// Scene Textures
Texture2D<float3> SceneColor;
Texture2D<float> SceneDepth;

// Output Texture
RWTexture2D<float4> Output;

struct VolumeSample {
    float SDist;
    float Density;
    
    /// Returns true if this sample is outside the volume.
    inline bool IsOutside() { return Density == 0.0; }
};

/// Returns the signed distance in the X component, and the density in the Y component.
VolumeSample SampleVolume(const float3 Point) {
    // Calculate the signed distance to the volume.
    const float UDist = distance(Cloud.Position, Point);
    VolumeSample Sample;
    Sample.SDist = abs(UDist - SPHERE_SIZE);
    Sample.Density = UDist <= SPHERE_SIZE ? Cloud.Density : 0.0; // Homogeneous for now.
    return Sample; 
}

// Anisotropic scattering function for clouds.
// Source: <https://www.guerrilla-games.com/read/nubis-cubed>
float HenyeyGreenstein(float VdotL, float G) {
    const float G2 = G * G;
    const float num = 1.0 - G2;
    const float denom = 1.0 + G2 - 2.0 * G * VdotL;
    const float rsqrt_denom = rsqrt(denom);
    return num * rsqrt_denom * rsqrt_denom * rsqrt_denom * 0.07957747154594766788444188168626;
}

/// Trace the scene, find out how much light is being absorped.
float3 TraceAbsorption(const float3 Origin, const float3 Dir, const float ViewDistance) {
    // Traversal variables.
    float Distance = 0.0;
    float PathDensity = 0.0;
    
    for (uint s = 0; s < MAX_INDIRECT_STEPS; ++s) {
        // Sample the volume.
        const float3 SamplePos = Origin + Dir * Distance;
        const VolumeSample Sample = SampleVolume(SamplePos);
        
        // Calculate our step size based on the signed distance to the volume.
        const float StepSize = max(Cloud.MinStepSize, Sample.SDist);
        Distance += StepSize; // Move along the ray to the next location.
        
        // No work to be done outside the volume, just keep stepping.
        if (Sample.IsOutside()) continue;
        
        // We're inside the volume, accumulate density.
        PathDensity += Sample.Density * StepSize;
    }
    
    // Beer's Law <https://en.wikipedia.org/wiki/Beer%E2%80%93Lambert_law>
    const float3 Absorption = exp(-Cloud.Absorption * PathDensity);
    return Absorption;
}

float3 TraceVolume(const float3 ViewColor, const float3 Origin, const float3 Dir) {
    // Traversal variables.
    float Absorption = 0.0;
    float3 Luminance = 0.0;
    float Distance = 0.0;
    
    // Sun out-scattering will be identical everywhere along the ray, so we pre-calculate it.
    const float Scattering = Cloud.SunLuminance * HenyeyGreenstein(dot(Dir, Cloud.SunDir), 0.2);
    
    // Integrate luminance along the ray.
    for (uint s = 0; s < MAX_DIRECT_STEPS; ++s) {
        // Sample the volume at the current location.
        const float3 SamplePos = Origin + Dir * Distance;
        const VolumeSample Sample = SampleVolume(SamplePos);
        
        // Calculate our step size based on the signed distance to the volume.
        const float StepSize = max(Cloud.MinStepSize, Sample.SDist);
        Distance += StepSize; // Move along the ray to the next location.
        
        // No work to be done outside the volume, just keep stepping.
        if (Sample.IsOutside()) continue;
        
        // Calculate the total density along our step.
        const float StepDensity = Sample.Density * StepSize;
        
        // Integrate the absorption along the ray.
        Absorption += StepDensity * (1.0 - Absorption);
        
        // Integrate direct out-scattering from the sun. 
        Luminance += TraceAbsorption(SamplePos, Cloud.SunDir, Distance) * Scattering * StepDensity * (1.0 - Absorption);
    }
    
    // Finally, combine the view color with the luminance based on the absorption.
    return lerp(ViewColor, Luminance, saturate(Absorption));
}

float3 TraceVolumeBeer(const float3 ViewColor, const float3 Origin, const float3 Dir) {
    // Traversal variables.
    float3 Luminance = 0.0;
    float Distance = 0.0;
    float PathDensity = 0.0;
    
    // Sun out-scattering will be identical everywhere along the ray, so we pre-calculate it.
    const float Scattering = Cloud.SunLuminance * HenyeyGreenstein(dot(Dir, Cloud.SunDir), 0.2);
    
    // Integrate luminance along the ray.
    for (uint s = 0; s < MAX_DIRECT_STEPS; ++s) {
        // Sample the volume at the current location.
        const float3 SamplePos = Origin + Dir * Distance;
        const VolumeSample Sample = SampleVolume(SamplePos);
        
        // Calculate our step size based on the signed distance to the volume.
        const float StepSize = max(Cloud.MinStepSize, Sample.SDist);
        Distance += StepSize; // Move along the ray to the next location.
        
        // No work to be done outside the volume, just keep stepping.
        if (Sample.IsOutside()) continue;
        
        // Calculate the total density along our step.
        const float StepDensity = Sample.Density * StepSize;
        
        // Integrate the absorption along the ray.
        PathDensity += StepDensity;
        
        // Beer's Law <https://en.wikipedia.org/wiki/Beer%E2%80%93Lambert_law>
        const float3 PartialAbsorption = exp(-Cloud.Absorption * PathDensity);
        
        // Integrate direct out-scattering from the sun. 
        Luminance += TraceAbsorption(SamplePos, Cloud.SunDir, Distance) * Scattering * PartialAbsorption;
    }
    
    // Beer's Law <https://en.wikipedia.org/wiki/Beer%E2%80%93Lambert_law>
    const float3 Absorption = exp(-Cloud.Absorption * PathDensity);
    
    // Finally, combine the view color with the luminance based on the absorption.
    return ViewColor * Absorption + Luminance;
}

// Compute Shader code
[numthreads(THREADS_X, THREADS_Y, THREADS_Z)]
void MainCS(uint2 DispatchThreadId : SV_DispatchThreadID) {
    // Calculate the pixel coordinate of this thread.
    const uint2 Pixel = View.ViewRectMinAndSize.xy + DispatchThreadId;
    
	// Make sure this pixel isn't outside the viewport bounds.
    if (any(Pixel >= View.ViewRectMinAndSize.zw)) return;
	
    // Calculate the UV coordinate of the current pixel.
    const float2 UV = GetPixelUV(Pixel);
    
    // Get the ray origin & direction.
    const float3 RayOrigin = GetRayOrigin();
    const float3 RayDirection = GetRayDirection(UV);
    
    // Ray vs Sphere intersection test.
    if (Cloud.Method == 1) {
        const float3 FinalColor = TraceVolumeBeer(SceneColor[Pixel], RayOrigin, RayDirection);
        Output[Pixel] = float4(FinalColor, 1.0);
    } else {
        const float3 FinalColor = TraceVolume(SceneColor[Pixel], RayOrigin, RayDirection);
        Output[Pixel] = float4(FinalColor, 1.0);
    }
}
