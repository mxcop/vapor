#include "Common.ush"

// Cloud Parameters
float3 Cloud_Position;
float3 Cloud_SunDir;

// Ray Marching Parameters
static const float BASE_STEP_SIZE = 0.001; // cm
static const float STEP_SIZE_MULT = 1.0;
static const uint MAX_STEP_COUNT = 256;

// Volume Parameters
static const float SPHERE_SIZE = 100.0; // cm
static const float VOLUME_DENSITY = 0.05;
static const float3 VOLUME_ABSORPTION = float3(1.1, 1.0, 0.9);
static const float3 SUN_LUMINANCE = float3(1.2, 1.0, 0.8);

// Scene Textures
Texture2D<float3> SceneColor;
Texture2D<float> SceneDepth;

// Output Texture
RWTexture2D<float4> Output;

/// Returns the signed distance in the X component, and the density in the Y component.
float2 SampleVolume(const float3 Point) {
    // Calculate the signed distance to the volume.
    const float UDist = distance(Cloud_Position, Point);
    const float SDist = UDist - SPHERE_SIZE;
    return float2(SDist, VOLUME_DENSITY); // Homogeneous for now.
}

/// Trace the scene, find out how much light is being absorped.
float3 TraceAbsorption(const float3 Origin, const float3 Dir) {
    // Traversal variables.
    float Distance = 0.0;
    float Material = 0.0;
    
    for (uint s = 0; s < MAX_STEP_COUNT; ++s) {
        // Sample the volume.
        const float3 SamplePos = Origin + Dir * Distance;
        const float2 Sample = SampleVolume(SamplePos);
        const float StepSize = max(0.1, abs(Sample.x));
        
        // We're inside the volume, accumulate absorption.
        if (Sample.x < 0.1) Material += Sample.y * StepSize;
        
        // Step forward.
        Distance += StepSize;
    }
    
    const float3 Absorption = exp(-VOLUME_ABSORPTION * Material);
    return Absorption;
}

float3 TraceVolume(const float3 ViewColor, const float3 Origin, const float3 Dir) {
    // Traversal variables.
    float Distance = 0.0;
    float Material = 0.0;
    float3 Luminance = float3(0.0, 0.0, 0.0);
    
    for (uint s = 0; s < MAX_STEP_COUNT; ++s) {
        // Sample the volume.
        const float3 SamplePos = Origin + Dir * Distance;
        const float2 Sample = SampleVolume(SamplePos);
        const float StepSize = max(0.1, abs(Sample.x));
        
        // We're inside the volume, accumulate absorption.
        if (Sample.x < 0.1) {
            Material += Sample.y * StepSize;
            Luminance += exp(-VOLUME_ABSORPTION * Material) * SUN_LUMINANCE * TraceAbsorption(SamplePos, Cloud_SunDir) * StepSize;
        }
        
        // Step forward.
        Distance += StepSize;
    }
    
    const float3 Absorption = exp(-VOLUME_ABSORPTION * Material);
    return ViewColor * Absorption + ((Material > 0.0) ? Luminance / Material : Luminance);
}

// Compute Shader code
[numthreads(THREADS_X, THREADS_Y, THREADS_Z)]
void MainCS(uint2 DispatchThreadId : SV_DispatchThreadID) {
    // Calculate the pixel coordinate of this thread.
    const uint2 Pixel = View.ViewRectMinAndSize.xy + DispatchThreadId;
    
	// Make sure this pixel isn't outside the viewport bounds.
    if (any(Pixel >= View.ViewRectMinAndSize.zw)) return;
	
    // Calculate the UV coordinate of the current pixel.
    const float2 UV = GetPixelUV(Pixel);
    
    // Get the ray origin & direction.
    const float3 RayOrigin = GetRayOrigin();
    const float3 RayDirection = GetRayDirection(UV);
    
    // Ray vs Sphere intersection test.
    const float3 FinalColor = TraceVolume(SceneColor[Pixel], RayOrigin, RayDirection);
    
    // Fetch the color and depth of the pixel.
    // const float3 PixelColor = SceneColor[Pixel];
    // const float3 FinalColor = PixelColor * Absorption; // lerp(PixelColor, float3(1.0, 1.0, 1.0), Absorbtion);
    
    Output[Pixel] = float4(FinalColor, 1.0);
}
