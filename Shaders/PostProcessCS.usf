// Custom SceneViewExtension Template for Unreal Engine
// Copyright 2023 - 2025 Ossi Luoto
// 
// Custom CS PostProcessing Shader

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "/Engine/Private/ScreenPass.ush"
#include "/Engine/Private/SceneTexturesCommon.ush"
#include "/Engine/Private/DeferredShadingCommon.ush"

// Cloud Parameters
float3 Cloud_Position;
float3 Cloud_SunDir;

// Scene Textures
Texture2D<float4> SceneColor;
Texture2D<float4> SceneDepth;

// Output
RWTexture2D<float4> Output;

/// Get the UV coordinate for a given pixel.
float2 GetUV(const uint2 pixel) { return (float2(pixel) + 0.5 - View.TemporalAAJitter.xy) * View.ViewSizeAndInvSize.zw; }

/// Get the depth value for a given pixel along the given ray.
float GetPixelDepth(const uint2 pixel, const float3 rd) { return ConvertFromDeviceZ(SceneDepth[pixel].r) / dot(rd, View.ViewForward); }

/// Get the ray origin of the current view.
float3 GetRayOrigin() { return View.WorldViewOriginHigh + View.WorldViewOriginLow; }

/// Get the ray direction of the current view for a given UV coordinate.
float3 GetRayDirection(const float2 uv) {
    const float2 screen = GetScreenPositionForProjectionType((uv - View.ScreenPositionScaleBias.wz) / View.ScreenPositionScaleBias.xy, 1.0);
    return normalize(mul(float4(screen, 1.0, 1.0), View.ScreenToTranslatedWorld).xyz);
}

/// Intersect a sphere with a ray.
float2 RayIntersectSphere(float3 ro, float3 rd, float3 ce, float ra) {
    float3 oc = ro - ce;
    float b = dot(oc, rd);
    float3 qc = oc - b * rd;
    float h = ra * ra - dot(qc, qc);
    if (h < 0.0) return float2(-1.0, -1.0);
    h = sqrt(h);
    return float2(-b - h, -b + h);
}

// Compute Shader code
[numthreads(THREADS_X, THREADS_Y, THREADS_Z)]
void MainCS(uint2 DispatchThreadId : SV_DispatchThreadID) {
    // Calculate the pixel coordinate of this thread.
    const uint2 pixel = View.ViewRectMinAndSize.xy + DispatchThreadId;
    
	// Make sure this pixel isn't outside the viewport bounds.
    if (any(pixel >= View.ViewRectMinAndSize.zw)) return;
	
    // Calculate the UV coordinate of the current pixel.
    const float2 uv = GetUV(pixel);
    
    // Get the ray origin & direction.
    const float3 ro = GetRayOrigin();
    const float3 rd = GetRayDirection(uv);
    
    // Ray vs Sphere intersection test.
    const float2 t = RayIntersectSphere(ro, rd, Cloud_Position, 100.0);
    
    // Fetch the color and depth of the pixel.
    const float3 color = SceneColor[pixel].rgb;
    const float depth = GetPixelDepth(pixel, rd);
    
    // Miss
    if (t.y < 0.0 || t.x >= depth) {
        Output[pixel] = float4(color, 1.0);
        return;
    }
    
    // Hit
    const float3 normal = normalize((ro + rd * t.x) - Cloud_Position);
    const float ndotl = max(1e-3, dot(normal, Cloud_SunDir));
    Output[pixel] = float4(ndotl.xxx, 1.0);
}
