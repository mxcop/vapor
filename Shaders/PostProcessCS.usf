// Custom SceneViewExtension Template for Unreal Engine
// Copyright 2023 - 2025 Ossi Luoto
// 
// Custom CS PostProcessing Shader

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "/Engine/Private/ScreenPass.ush"

// Shader parameters
float3 GetTranslatedWorldPositionFromScreenUV(float2 ScreenUV, float SceneDepth) {
    float2 ScreenPosition = (ScreenUV - View.ScreenPositionScaleBias.wz) / View.ScreenPositionScaleBias.xy;
    return mul(float4(GetScreenPositionForProjectionType(ScreenPosition, SceneDepth), SceneDepth, 1), PrimaryView.ScreenToTranslatedWorld).xyz;
}

float3 GetCameraPosition() {
    return mul(float4(0.0, 0.0, 0.0, 1.0), PrimaryView.ScreenToTranslatedWorld).xyz;
}

float2 Sphere(float3 ro, float3 rd, float3 ce, float ra) {
    float3 oc = ro - ce;
    float b = dot(oc, rd);
    float3 qc = oc - b * rd;
    float h = ra * ra - dot(qc, qc);
    if (h < 0.0) return float2(-1.0, -1.0);
    h = sqrt(h);
    return float2(-b - h, -b + h);
}

float3 Position;

// SceneColor texture
Texture2D OriginalSceneColor;

// SceneColor Viewport parameters
SCREEN_PASS_TEXTURE_VIEWPORT(SceneColorViewport)

// Output
RWTexture2D<float4> Output;

// Compute Shader code
[numthreads(THREADS_X, THREADS_Y, THREADS_Z)]
void MainCS(uint2 DispatchThreadId : SV_DispatchThreadID)
{
	// Check that we are in scope
    if (any(DispatchThreadId >= SceneColorViewport_ViewportMax))
    {
        return;
    }
	
    // Calculate SampleUV with viewport parameters
    const float2 uv = (float2(SceneColorViewport_ViewportMin) + (DispatchThreadId + 0.5)) * SceneColorViewport_ExtentInverse;
    
    const float3 ro = View.WorldViewOriginHigh;
    const float3 rd = normalize(GetTranslatedWorldPositionFromScreenUV(uv, 1.0));
    const float2 t = Sphere(ro, rd, Position, 100.0);
    
    if (t.x > 0.0) {
        const float3 normal = normalize((ro + rd * t.x) - Position);
        Output[SceneColorViewport_ViewportMin + DispatchThreadId] = float4(normal * 0.5 + 0.5, 1.0);
    } else {
        Output[SceneColorViewport_ViewportMin + DispatchThreadId] = OriginalSceneColor.SampleLevel(GlobalPointClampedSampler, uv, 0);
    }
    
    // Output[SceneColorViewport_ViewportMin + DispatchThreadId] = float4(ro, 1.0);
    
    // Reconstruct NDC space [-1, 1]
//    float2 ndc = sampleUV * 2.0f - 1.0f;

//// Set up a clip-space position at the near plane (Z = 0)
//    float4 clipPos = float4(ndc, 0.0f, 1.0f);

//// Transform to view/world space
//    float4 worldPos = mul(clipPos, CameraView_ViewProjection);
//    worldPos /= worldPos.w;

//// Camera world position (origin)
//    float3 cameraPos = mul(float4(0, 0, 0, 1), CameraView_ViewProjection).xyz;

//// Ray direction: from camera position toward worldPos
//    float3 rayDir = normalize(worldPos.xyz - cameraPos);
//    Output[SceneColorViewport_ViewportMin + DispatchThreadId] = float4(rayDir * 0.5 + 0.5, 1.0);
    
    // sample OriginalColor
    // float4 OriginalColor = OriginalSceneColor.SampleLevel(GlobalPointClampedSampler, sampleUV, 0);

    // To test that everything is working, switch Red and Blue
    // float4 OutputColor = float4(OriginalColor.z, OriginalColor.y, OriginalColor.x, OriginalColor.w);

    // Write output
    // Output[SceneColorViewport_ViewportMin + DispatchThreadId] = OutputColor;
}
