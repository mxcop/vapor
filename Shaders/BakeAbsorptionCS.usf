#include "Common.ush"

static const uint INTEGRATION_STEPS = 256;

// Cloud Parameters
ConstantBuffer<CloudParameters> Cloud;

// Output Spherical Harmonics
RWTexture3D<float4> OutputSH;

/// Accumulate data into spherical harmonics.
/// Coefficients : <https://en.wikipedia.org/wiki/Table_of_spherical_harmonics#Real_spherical_harmonics>
void AccumulateSH1(inout float4 SH1, const float3 Dir, const float Value) {
    // L_[00]
    static const float C0 = 0.282095; // k = (0.5 * sqrt(1.0 / PI))
    SH1.x += Value * C0;

    // L_[1m], Linear terms: (m = -1..=1)
    static const float C1 = 0.488603; // k = (sqrt(3.0 / (4.0 * PI)))
    SH1.y += Value * (C1 * Dir.x); // Y_[1-1]
    SH1.z += Value * (C1 * Dir.y); // Y_[10]
    SH1.w += Value * (C1 * Dir.z); // Y_[11]
}

/// Generate equadistant points on the unit sphere.
/// Source: <https://stackoverflow.com/questions/9600801/evenly-distributing-n-points-on-a-sphere>
float3 FibonacciSphere(const uint Step, const uint Steps) {
    static const float GOLDEN_RATIO = 1.618033988749895;
    const float Theta = 2.0 * 3.14159265359 * Step / GOLDEN_RATIO;
    const float Phi = acos(1.0 - 2.0 * (Step + 0.5) / Steps);
    const float SinPhi = sin(Phi);
    return normalize(float3(cos(Theta) * SinPhi, sin(Theta) * SinPhi, cos(Phi)));
}

CloudSample SampleVolume(const float3 UVW) {
    return SampleCloud(Cloud, UVW.xzy);
}

/// Trace the scene, find out how much light is being absorped.
float TracePathDensity(const float3 Origin, const float3 Dir) {
    // Intersect the bounds of the volume, return early if we miss.
    const float2 BoundsIntersection = RayAABB(Origin, Dir, float3(0.0, 0.0, 0.0), float3(1.0, 1.0, 1.0));
    
    // Traversal variables.
    float Distance = max(0.0, BoundsIntersection.x);
    float PathDensity = 0.0;
    float StepSize = 0.006;
    
    for (uint s = 0; s < 512; ++s) {
        if (Distance >= BoundsIntersection.y) break;
        
        // Sample the volume.
        const float3 SamplePos = Origin + Dir * Distance;
        const CloudSample Sample = SampleVolume(SamplePos);
        Distance += StepSize;
        
        // No work to be done outside the volume, just keep stepping.
        if (Sample.IsOutside()) continue;
        
        // We're inside the volume, accumulate density.
        PathDensity += (Sample.Density() / Cloud.Density) * StepSize;
    }
    
    return PathDensity;
}

[numthreads(THREADS_X, THREADS_Y, THREADS_Z)]
void MainCS(uint3 DispatchThreadId : SV_DispatchThreadID) {
    //uint W, H, D; // Get the UVW of this thread.
    //OutputSH.GetDimensions(W, H, D);
    //const uint3 OutputSize = uint3(W, H, D);
    const float3 UVW = (float3(DispatchThreadId) + 0.5) / 512.0;

    // Create empty spherical harmonics.
    float4 SH1 = float4(0.0, 0.0, 0.0, 0.0);
    
    // Integrate absorption from our threads position in the volume.
    for (uint Step = 0; Step < INTEGRATION_STEPS; ++Step) {
        // Trace volume absorption for this step.
        const float3 Dir = FibonacciSphere(Step, INTEGRATION_STEPS);
        const float PathDensity = TracePathDensity(UVW, Dir);
        
        // Accumulate the absorption.
        AccumulateSH1(SH1, Dir, PathDensity);
    }
    // const float PathDensity = TracePathDensity(UVW, Cloud.SunDir);
    
    // Output the normalized spherical harmonics.
    OutputSH[DispatchThreadId] = SH1 * 25.0 / INTEGRATION_STEPS;
}
