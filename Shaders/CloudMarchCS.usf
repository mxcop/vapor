#include "Common.ush"
#include "Cloud.ush"

// Ray Marching Parameters
static const uint MAX_DIRECT_STEPS = 256;
static const uint MAX_INDIRECT_STEPS = 256;

// Cloud Parameters
ConstantBuffer<CloudInstance> Cloud;

// Scene Textures
Texture2D<float3> SceneColor;
Texture2D<float> SceneDepth;

Texture3D<float> DensityCacheDataSRV;
RWTexture3D<float> DensityCacheData;
RWTexture3D<uint> DensityCacheFlags;

// Output Texture
RWTexture2D<float4> Output;

#if DEBUG
static int STEP_COUNT = 0;
static int STEP_COUNT2 = 0;
#endif

/// Calculate the threshold path density at which the absorption reaches a given threshold.
float CalcPathDensityThreshold(const float AbsorptionThreshold) {
    return -log(AbsorptionThreshold) / min(min(Cloud.Absorption.r, Cloud.Absorption.g), Cloud.Absorption.b);
}

/// Calculate a distance-based step size for ray-marching.
float CalcStepSize(const float Distance) {
    // return Cloud.PrimaryNearStep + Distance * Cloud.PrimaryStepPerDistance;
    return max(Cloud.PrimaryNearStep, sqrt(Distance) * Cloud.PrimaryStepPerDistance);
}

CloudSample SampleVolume(const float3 Point) {
    return SampleCloud(Cloud, Point);
    //if (Sample.IsOutside()) return Sample;
    //const float WindOffset = float3(0.25, 0.4, 0.8) * View.GameTime * 0.1;
    //const float4 Erosion = Noise.Sample(GlobalBilinearWrappedSampler, (Point * 0.0001) - WindOffset);
    //const float BillowyFreqGradient = pow(Sample.Density() / Cloud.Density, 0.25);
    //const float BillowyNoise = lerp(Erosion.b * 0.3, Erosion.a * 0.3, BillowyFreqGradient);
    //return CloudSample::Inside(ValueErosion(Sample.Density() / Cloud.Density, BillowyNoise) * Cloud.Density);
}

/// Anisotropic scattering function for clouds.
/// Source: <https://www.guerrilla-games.com/read/nubis-cubed>
float HenyeyGreenstein(float VdotL, float G) {
    const float G2 = G * G;
    const float num = 1.0 - G2;
    const float denom = 1.0 + G2 - 2.0 * G * VdotL;
    const float rsqrt_denom = rsqrt(denom);
    return num * rsqrt_denom * rsqrt_denom * rsqrt_denom * 0.07957747154594766788444188168626;
}

//struct CacheValue {
//    uint Value;
//    bool HasValue() { return (Value & 0x80000000) != 0x00; }
//    uint GetValue() { return Value & 0x7FFFFFFF; }
//};

//CacheValue CacheFetch(const uint3 Index, const bool Leaching) {
//    CacheValue Value;
//    // If we are leaching off the cache, just fetch the data regardless of whether its filled.
//    if (Leaching) {
//        Value.Value = CacheTexture[Index];
//        return Value;
//    }
//    // Otherwise, we atomic or the value, to claim the slot in case its empty.
//    InterlockedOr(CacheTexture[Index], 0x80000000, Value.Value);
//    return Value;
//}

//void CacheWrite(const uint3 Index, const uint Value) {
//    // Write out to the cache, make sure to keep the filled bit set.
//    CacheTexture[Index] = 0x80000000 | Value;
//}

/// Trace the scene, find out how much light is being absorped.
float3 TraceAbsorption(const float3 Origin, const float3 Dir, const float SunDot, const float PathDensityThreshold) {
    // Intersect the bounds of the volume, return early if we miss.
    const float2 BoundsIntersection = RayAABB(Origin, Dir, Cloud.Position - HALF_VOLUME_SIZE, Cloud.Position + HALF_VOLUME_SIZE);
    
    // Traversal variables.
    float Distance = max(0.0, BoundsIntersection.x);
    
    float PathDensity = 0.0;
    //for (uint s = 0; s < 3; ++s) {
    //    // Sample the volume.
    //    const float3 SamplePos = Origin + Dir * Distance;
    //    const CloudSample Sample = SampleVolume(SamplePos);
        
    //    // No work to be done outside the volume, just keep stepping.
    //    if (Sample.IsOutside()) {
    //        Distance += max(Cloud.PrimaryMinSDFStep, Sample.SDist()); // Move along the ray to the next location.
    //        continue;
    //    }
    //    Distance += Cloud.SecondaryStep;
        
    //    // We're inside the volume, accumulate density.
    //    PathDensity += Sample.Density() * Cloud.SecondaryStep;
    //    if (PathDensity > PathDensityThreshold) break;
    //}
    
    // Sample the cache.
    const float3 UVW = ((Origin + Dir * Distance) - Cloud.Position) / HALF_VOLUME_SIZE * 0.5 + 0.5;
    const uint3 CacheIndex = (uint3)(UVW * VOLUME_RESOLUTION);
    const uint3 FlagsIndex = CacheIndex >> uint3(2, 2, 1);
    const uint3 FlagIndex = CacheIndex & uint3(3, 3, 1);
    const uint FlagMask = 1 << (FlagIndex.x + FlagIndex.y * 4 + FlagIndex.z * 4 * 4);
    uint Flag;
    InterlockedOr(DensityCacheFlags[FlagsIndex], FlagMask, Flag);
    if (Flag & FlagMask) { // Cache slot is already filled.
        const float CacheData = DensityCacheDataSRV.Sample(GlobalBilinearClampedSampler, UVW);
        PathDensity = Remap(CacheData, 0.0f, 1.0f, 0.0f, 16.0f);
#if DEBUG
        STEP_COUNT2++;
#endif
    } else { // Cache slot is not filled yet.
        for (uint s = 0; s < MAX_INDIRECT_STEPS; ++s) {
            if (Distance >= BoundsIntersection.y) break;
        
            // Sample the volume.
            const float3 SamplePos = Origin + Dir * Distance;
            const CloudSample Sample = SampleVolume(SamplePos);
        
            // No work to be done outside the volume, just keep stepping.
            if (Sample.IsOutside()) {
                Distance += max(Cloud.PrimaryMinSDFStep, Sample.SDist()); // Move along the ray to the next location.
                continue;
            }
            Distance += Cloud.SecondaryStep;
        
            // We're inside the volume, accumulate density.
            PathDensity += Sample.Density() * Cloud.SecondaryStep;
            if (PathDensity > PathDensityThreshold) break;
        }
#if DEBUG
        STEP_COUNT++;
#endif
        DensityCacheData[CacheIndex] = Remap(PathDensity, 0.0f, 16.0f, 0.0f, 1.0f);
    }
    
//    const float3 UVW = ((Origin + Dir * Distance) - Cloud.Position) / HALF_VOLUME_SIZE * 0.5 + 0.5;
//    const uint3 CacheIndex = (uint3) (UVW * VOLUME_RESOLUTION);
//    const CacheValue CacheRead = CacheFetch(CacheIndex, false);
    
//    if (CacheRead.HasValue() == false) {
//        for (uint s = 0; s < MAX_INDIRECT_STEPS; ++s) {
//            if (Distance >= BoundsIntersection.y) break;
        
//            // Sample the volume.
//            const float3 SamplePos = Origin + Dir * Distance;
//            const CloudSample Sample = SampleVolume(SamplePos);
        
//            // No work to be done outside the volume, just keep stepping.
//            if (Sample.IsOutside()) {
//                Distance += max(Cloud.PrimaryMinSDFStep, Sample.SDist()); // Move along the ray to the next location.
//                continue;
//            }
//            Distance += Cloud.SecondaryStep;
        
//            // We're inside the volume, accumulate density.
//            PathDensity += Sample.Density() * Cloud.SecondaryStep;
//            if (PathDensity > PathDensityThreshold) break;
//        }
        
//#if DEBUG
//        STEP_COUNT++;
//#endif
        
//        CacheWrite(CacheIndex, (uint)Remap(PathDensity, 0.0f, 16.0f, 0.0f, 2147483647.0f));
//    } else {
//        PathDensity += Remap((float)CacheRead.GetValue(), 0.0f, 2147483647.0f, 0.0f, 16.0f);
        
//#if DEBUG
//        STEP_COUNT2++;
//#endif
//    }
    
    // Beer's Law <https://en.wikipedia.org/wiki/Beer%E2%80%93Lambert_law>
    float3 Absorption = exp(-Cloud.Absorption * PathDensity);
    
    // Multi-scatter approximation.
    if (Cloud.MultiScattering) {
        const RoughSample Sample = SampleCloudRough(Cloud, Origin);
        const float3 MsVolume = exp(-Cloud.Absorption * PathDensity * Remap(SunDot, 0.0, 0.9, Remap(Sample.SDist, 0.0, -16.0 * UNITS_PER_VOXEL, 0.05, 0.25), 0.25));
        Absorption += MsVolume;
    }
    
    return Absorption;
}

float3 TraceVolume(const float3 ViewColor, const float3 Origin, const float3 Dir) {
    // Intersect the bounds of the volume, return early if we miss.
    const float2 BoundsIntersection = RayAABB(Origin, Dir, Cloud.Position - HALF_VOLUME_SIZE, Cloud.Position + HALF_VOLUME_SIZE);
    if (BoundsIntersection.x > BoundsIntersection.y) return ViewColor;
    
    // Traversal variables.
    float Absorption = 0.0;
    float3 Luminance = 0.0;
    float PathDensity = 0.0;
    float Distance = max(0.0, BoundsIntersection.x);
    
    // Calculate at what path density we will reach the extinction threshold.
    const float PathDensityThreshold = CalcPathDensityThreshold(Cloud.SecondaryExtinctThreshold);
    
    // Sun out-scattering will be identical everywhere along the ray, so we pre-calculate it.
    const float SunDot = dot(Dir, Cloud.SunDir);
    const float3 Scattering = Cloud.SunLuminance * HenyeyGreenstein(SunDot, 0.2);
    
    // Integrate luminance along the ray.
    for (uint s = 0; s < MAX_DIRECT_STEPS; ++s) {
        if (Distance >= BoundsIntersection.y) break;
        
        // Sample the volume at the current location.
        const float3 SamplePos = Origin + Dir * Distance;
        const CloudSample Sample = SampleVolume(SamplePos);
        
        // No work to be done outside the volume, just keep stepping.
        if (Sample.IsOutside()) {
            Distance += max(Cloud.PrimaryMinSDFStep, Sample.SDist()); // Move along the ray to the next location.
            continue;
        }
        const float StepSize = CalcStepSize(Distance);
        Distance += StepSize;
        
        // Calculate the total density along our step.
        const float StepDensity = Sample.Density() * StepSize;
        
        // Integrate the absorption along the ray.
        Absorption = saturate(Absorption + StepDensity * (1.0 - Absorption));
        if (Absorption > 0.999) {
            Absorption = 1.0;
            break;
        }
        
        // Integrate density along the ray.
        PathDensity += StepDensity;
        
        // Integrate direct out-scattering from the sun. 
        if (Cloud.DirectScattering) {
            Luminance += TraceAbsorption(SamplePos, Cloud.SunDir, SunDot, PathDensityThreshold) * Scattering * StepDensity * (1.0 - Absorption);
        }
        
        // Integrate ambient out-scattering.
        if (Cloud.AmbientScattering) {
            const RoughSample Sample = SampleCloudRough(Cloud, Origin);
            const float DimensionalProfile = min(1.0, -Sample.SDist / UNITS_PER_VOXEL * 0.2);
            Luminance += StepDensity * pow(1.0 - DimensionalProfile, 0.5) * Cloud.AmbientFlux;
        }
    }
    
    // Beer's Law <https://en.wikipedia.org/wiki/Beer%E2%80%93Lambert_law>
    // const float3 PathAbsorption = exp(-Cloud.Absorption * PathDensity);
    
    // Finally, combine the view color with the luminance based on the absorption.
    return ViewColor * (1.0 - Absorption) + Luminance;
}

// Compute Shader code
[numthreads(THREADS_X, THREADS_Y, THREADS_Z)]
void MainCS(uint2 DispatchThreadId : SV_DispatchThreadID) {
    // Calculate the pixel coordinate of this thread.
    const uint2 Pixel = View.ViewRectMinAndSize.xy + DispatchThreadId;
    
	// Make sure this pixel isn't outside the viewport bounds.
    if (any(Pixel >= View.ViewRectMinAndSize.zw)) return;
	
    // Calculate the UV coordinate of the current pixel.
    const float2 UV = GetPixelUV(Pixel);
    
    // Get the ray origin & direction.
    const float3 RayOrigin = GetRayOrigin();
    const float3 RayDirection = GetRayDirection(UV);
    
    // Ray vs Sphere intersection test.
    const float3 FinalColor = TraceVolume(SceneColor[Pixel], RayOrigin, RayDirection);
    
#if DEBUG
    Output[Pixel] = float4((float)STEP_COUNT / (float)MAX_DIRECT_STEPS, (float)STEP_COUNT2 / (float)MAX_DIRECT_STEPS, 0.0, 1.0);
#else
    Output[Pixel] = float4(FinalColor, 1.0);
#endif
}
