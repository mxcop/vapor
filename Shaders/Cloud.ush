#pragma once

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "Common.ush"

static const float UNITS_PER_VOXEL = 800.0; // 8 m
static const float3 VOLUME_RESOLUTION = float3(512, 512, 64);
static const float3 VOLUME_SIZE = UNITS_PER_VOXEL * VOLUME_RESOLUTION;
static const float3 HALF_VOLUME_SIZE = VOLUME_SIZE * 0.5;

/// 4 types of noise packed into a single texture.
/// Channels: HFAlligator, HFCurlyWorley, LFAlligator, LFCurlyWorley
Texture3D<float4> Noise;

/// Sample taken from a cloud.
struct CloudSample {
    float Value;
    
    /// Create a cloud sample which resides outside the cloud.
    static CloudSample Outside(const float SDist) { return (CloudSample)SDist; }
    /// Create a cloud sample which resides inside the cloud.
    static CloudSample Inside(const float Density) { return (CloudSample)(-Density); }
    
    /// Returns true if this sample is outside the volume.
    inline bool IsOutside() { return Value > 0.0; }
    /// Returns the density of the cloud for this sample. (if `IsOutside() == false`)
    inline float Density() { return -Value; }
    /// Returns the signed distance to the cloud for this sample. (if `IsOutside() == true`)
    inline float SDist() { return Value; }
};

struct RoughSample {
    float SDist;
    float Density;
};

/// Collection of data required to render a cloud.
struct CloudInstance {
    // Volume Data
    float3 Position;
    float3 Absorption;
    float Density;
    
    // Light Data
    float3 SunDir;
    float3 SunLuminance;
    float3 AmbientFlux;
        
    // Primary Ray Options
    float PrimaryNearStep;
    float PrimaryStepPerDistance;
    float PrimaryMinSDFStep;
    
    uint DirectScattering;
    uint MultiScattering;
    uint AmbientScattering;
    
    // Secondary Ray Options
    float SecondaryStep;
    float SecondaryExtinctThreshold;
    
    float NoiseFreq;
    
    // Textures
    Texture3D<float> DensityTexture;
    Texture3D<float> SDFTexture;
};

float ValueErosion(const float Value, const float Erosion) {
	const float InvErosion = (1.0 - Erosion);
    return saturate((Value - Erosion) / InvErosion);
}

/// Sample the cloud.
CloudSample SampleCloud(ConstantBuffer<CloudInstance> Cloud, const float3 Point) {
    const float3 UVW = (Point - Cloud.Position) / HALF_VOLUME_SIZE * 0.5 + 0.5;
    
    // Sample the Signed Distance Field.
    // The SDF is stored from -32 to 512 in a UNorm texture encoded in voxel-space.
    const float NormSDist = Cloud.SDFTexture.Sample(GlobalBilinearClampedSampler, UVW);
    const float SDist = (NormSDist * (32.0 + 512.0) - 32.0) * UNITS_PER_VOXEL;
    
    // If the distance is above zero, we're outside the cloud, return the signed distance.
    if (SDist > 0.0) return CloudSample::Outside(SDist);
    
    // We're inside the volume, so we fetch the density and return it instead.
    const float Density = Cloud.DensityTexture.Sample(GlobalBilinearClampedSampler, UVW);
    
    const float WindOffset = float3(0.25, 0.4, 0.8) * View.GameTime * 0.1;
    const float4 NoiseSample = Noise.Sample(GlobalBilinearWrappedSampler, (Point * Cloud.NoiseFreq) - WindOffset);
    
    const float DimensionalProfile = min(1.0, -SDist / UNITS_PER_VOXEL * 0.5);
    const float BillowyFreqGradient = pow(DimensionalProfile, 0.25);
    const float BillowyNoise = lerp(NoiseSample.b * 0.3, NoiseSample.r * 0.3, BillowyFreqGradient);

    float ErodedDensity = ValueErosion(Density, BillowyNoise);
    // Modify User density scale
    float powered_density_scale = pow(saturate(Cloud.Density), 4.0);
    // Apply User Density Scale Data to Result
    ErodedDensity *= powered_density_scale;
    // Sharpen result and lower Density close to camera to both add details and reduce undersampling noise
    ErodedDensity = pow(ErodedDensity, lerp(0.3, 0.6, max(0.00001, powered_density_scale)));
    return CloudSample::Inside(ErodedDensity);
    // return CloudSample::Inside(Density * Cloud.Density);
}

RoughSample SampleCloudRough(ConstantBuffer<CloudInstance> Cloud, const float3 Point) {
    const float3 UVW = (Point - Cloud.Position) / HALF_VOLUME_SIZE * 0.5 + 0.5;
    RoughSample Sample;
    
    // Sample the Signed Distance Field.
    // The SDF is stored from -32 to 512 in a UNorm texture encoded in voxel-space.
    const float NormSDist = Cloud.SDFTexture.Sample(GlobalBilinearClampedSampler, UVW);
    Sample.SDist = (NormSDist * (32.0 + 512.0) - 32.0) * UNITS_PER_VOXEL;
    
    // We're inside the volume, so we fetch the density and return it instead.
    Sample.Density = Cloud.DensityTexture.Sample(GlobalBilinearClampedSampler, UVW);
    return Sample;
}
