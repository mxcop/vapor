#pragma once

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "Common.ush"

static const float UNITS_PER_VOXEL = 800.0; // 8 m

static const float3 VOLUME_RESOLUTION = float3(512, 512, 64);
static const float3 VOLUME_SIZE = UNITS_PER_VOXEL * VOLUME_RESOLUTION;
static const float3 HALF_VOLUME_SIZE = VOLUME_SIZE * 0.5;

/// 4 types of noise packed into a single texture.
/// Channels: HFAlligator, HFCurlyWorley, LFAlligator, LFCurlyWorley
Texture3D<float4> Noise;

/// Sample taken from a cloud.
struct CloudSample {
    float Value;
    
    /// Create a cloud sample which resides outside the cloud.
    static CloudSample Outside(const float SDist) { return (CloudSample)SDist; }
    /// Create a cloud sample which resides inside the cloud.
    static CloudSample Inside(const float Density) { return (CloudSample)(-Density); }
    
    /// Returns true if this sample is outside the volume.
    inline bool IsOutside() { return Value > 0.0; }
    /// Returns the density of the cloud for this sample. (if `IsOutside() == false`)
    inline float Density() { return -Value; }
    /// Returns the signed distance to the cloud for this sample. (if `IsOutside() == true`)
    inline float SDist() { return Value; }
};

struct RoughSample {
    float SDist;
    float Density;
};

/// Collection of data required to render a cloud.
struct CloudInstance {
    // Volume Data
    float3 Position;
    float3 Absorption;
    float Density;
    float ProfileWidth;
    
    // Light Data
    float3 SunDir;
    float3 SunLuminance;
    float3 AmbientLuminance;
        
    // Primary Ray Options
    float PrimaryNearStep;
    float PrimaryStepPerDistance;
    float PrimaryMinSDFStep;
    
    uint DirectScattering;
    uint MultiScattering;
    uint AmbientScattering;
    
    // Secondary Ray Options
    float SecondaryStep;
    float SecondaryExtinctThreshold;
    
    float NoiseFreq;
    float3 WindSpeed;
    
    // Textures
    Texture3D<float> DensityTexture;
    Texture3D<float> SDFTexture;
};

/// Calculate the threshold path density at which the absorption reaches a given threshold.
float CalcPathDensityThreshold(const float AbsorptionThreshold, const float3 Absorption) {
    return -log(AbsorptionThreshold) / min(min(Absorption.r, Absorption.g), Absorption.b);
}

float ValueErosion(const float Value, const float Erosion) {
	const float InvErosion = (1.0 - Erosion);
    return saturate((Value - Erosion) / InvErosion);
}

/// Sample the cloud.
CloudSample SampleCloud(ConstantBuffer<CloudInstance> Cloud, const float3 Point) {
    const float3 UVW = (Point - Cloud.Position) / HALF_VOLUME_SIZE * 0.5 + 0.5;
    
    // Sample the Signed Distance Field.
    // The SDF is stored from -32 to 512 in a UNorm texture encoded in voxel-space.
    const float NormSDist = Cloud.SDFTexture.Sample(GlobalBilinearClampedSampler, UVW);
    const float SDist = (NormSDist * (32.0 + 512.0) - 32.0) * UNITS_PER_VOXEL;
    
    // If the distance is above zero, we're outside the cloud, return the signed distance.
    if (SDist > 0.0) return CloudSample::Outside(SDist);
    
    // We're inside the volume, so we fetch the density and return it instead.
    const float Density = Cloud.DensityTexture.Sample(GlobalBilinearClampedSampler, UVW);
    
    const float3 WindOffset = Cloud.WindSpeed * View.GameTime;
    const float4 NoiseSample = Noise.Sample(GlobalBilinearWrappedSampler, (Point - WindOffset) * Cloud.NoiseFreq);
    
    const float DimensionalProfile = min(1.0, -SDist / Cloud.ProfileWidth);
    const float BillowyFreqGradient = pow(DimensionalProfile, 0.25);
    const float BillowyNoise = lerp(NoiseSample.b * 0.3, NoiseSample.r * 0.3, BillowyFreqGradient);

    float ErodedDensity = ValueErosion(DimensionalProfile, BillowyNoise);
    // Modify User density scale
    const float PowDensity = pow(saturate(Density * Cloud.Density), 4.0);
    // Apply User Density Scale Data to Result
    ErodedDensity *= PowDensity;
    // Sharpen result and lower Density close to camera to both add details and reduce undersampling noise
    ErodedDensity = pow(ErodedDensity, lerp(0.3, 0.6, max(0.00001, PowDensity)));
    return CloudSample::Inside(ErodedDensity);
}

RoughSample SampleCloudRough(ConstantBuffer<CloudInstance> Cloud, const float3 Point) {
    const float3 UVW = (Point - Cloud.Position) / HALF_VOLUME_SIZE * 0.5 + 0.5;
    RoughSample Sample;
    
    // Sample the Signed Distance Field.
    // The SDF is stored from -32 to 512 in a UNorm texture encoded in voxel-space.
    const float NormSDist = Cloud.SDFTexture.Sample(GlobalBilinearClampedSampler, UVW);
    Sample.SDist = (NormSDist * (32.0 + 512.0) - 32.0) * UNITS_PER_VOXEL;
    const float DimensionalProfile = min(1.0, -Sample.SDist / Cloud.ProfileWidth);
    
    // We're inside the volume, so we fetch the density and return it instead.
    const float DensityScale = Cloud.DensityTexture.Sample(GlobalBilinearClampedSampler, UVW);
    Sample.Density = DimensionalProfile; // Cloud.DensityTexture.Sample(GlobalBilinearClampedSampler, UVW);
    // Modify User density scale
    const float PowDensity = pow(saturate(DensityScale * Cloud.Density), 4.0);
    // Apply User Density Scale Data to Result
    Sample.Density *= PowDensity;
    // Sharpen result and lower Density close to camera to both add details and reduce undersampling noise
    Sample.Density = pow(Sample.Density, lerp(0.3, 0.6, max(0.00001, PowDensity)));
    return Sample;
}
